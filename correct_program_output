Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/binary0.smt2
Qualifier "Pos" [Var IntS "v"] (Binary Le (IntLit 0) (Var IntS "v"))
Qualifier "Neg" [Var IntS "v"] (Binary Le (Var IntS "v") (IntLit 0))

QMAP
--------
fromList []

Candidates
--------
[Candidate {solution = fromList [], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/bool03.smt2
SortDecl "Str" 0
UninterpFunction "cat" [] (DataS "Str" [])
UninterpFunction "not_the_hippopotamus" [] (DataS "Str" [])
UninterpFunction "dog" [] (DataS "Str" [])
Qualifier "Implies" [Var BoolS "v",Var BoolS "x"] (Binary Implies (Var BoolS "x") (Var BoolS "v"))
WFConstraint "$k1" [Var BoolS "bx",Var BoolS "v"]
HornConstraint [Var BoolS "bx",Var BoolS "v1"] (Binary Implies (Binary And (BoolLit True) (Binary Implies (Var BoolS "bx") (Var BoolS "v1"))) (Unknown (fromList [("bx",Var BoolS "bx"),("v",Var BoolS "v1")]) "$k1"))
HornConstraint [Var BoolS "bx",Var BoolS "zx",Var BoolS "v2"] (Binary Implies (Binary And (BoolLit True) (Binary And (Unary Not (Binary Eq (Func (DataS "Str" []) "cat" []) (Func (DataS "Str" []) "dog" []))) (Unknown (fromList [("bx",Var BoolS "bx"),("v",Var BoolS "v2")]) "$k1"))) (Binary Implies (Var BoolS "bx") (Var BoolS "v2")))

QMAP
--------
fromList [("$k1",QSpace {_qualifiers = [Binary Implies (Var BoolS "v") (Var BoolS "bx"),Binary Implies (Var BoolS "bx") (Var BoolS "v")], _maxCount = 2})]

Candidates
--------
[Candidate {solution = fromList [("$k1",fromList [Binary Implies (Var BoolS "bx") (Var BoolS "v")])], validConstraints = fromList [Binary Implies (Binary And (BoolLit True) (Binary And (Unary Not (Binary Eq (Func (DataS "Str" []) "cat" []) (Func (DataS "Str" []) "dog" []))) (Unknown (fromList [("bx",Var BoolS "bx"),("v",Var BoolS "v2")]) "$k1"))) (Binary Implies (Var BoolS "bx") (Var BoolS "v2")),Binary Implies (Binary And (BoolLit True) (Binary Or (Unary Not (Var BoolS "bx")) (Var BoolS "v1"))) (Unknown (fromList [("bx",Var BoolS "bx"),("v",Var BoolS "v1")]) "$k1")], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k1 -> {bx [37m==>[0m v}] (2 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/cons00.smt2
SortDecl "List" 1
Qualifier "eq" [Var (DataS "List" [IntS]) "x"] (Binary Eq (Var (DataS "List" [IntS]) "x") (Cons (DataS "List" [IntS]) "List" [IntLit 2]))

QMAP
--------
fromList []

Candidates
--------
[Candidate {solution = fromList [], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/func0.smt2
Qualifier "Eq" [Var (VarS "a") "v",Var (VarS "b") "z"] (Binary Eq (Var (VarS "a") "v") (Var (VarS "b") "z"))
UninterpFunction "bar" [IntS] BoolS
WFConstraint "$k0" [Var IntS "v0",Var IntS "v1"]
HornConstraint [Var IntS "v2",Var IntS "v3"] (Binary Implies (Unknown (fromList [("v0",Var IntS "v2"),("v1",Var IntS "v3")]) "$k0") (Binary Eq (Func BoolS "bar" [Var IntS "v2"]) (Func BoolS "bar" [Var IntS "v3"])))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Eq (Var IntS "v0") (Var IntS "v1"),Binary Eq (Var IntS "v1") (Var IntS "v0")], _maxCount = 2})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Eq (Var IntS "v1") (Var IntS "v0")])], validConstraints = fromList [Binary Implies (Unknown (fromList [("v0",Var IntS "v2"),("v1",Var IntS "v3")]) "$k0") (Binary Eq (Func BoolS "bar" [Var IntS "v2"]) (Func BoolS "bar" [Var IntS "v3"]))], invalidConstraints = fromList [], label = "0.0"},Candidate {solution = fromList [("$k0",fromList [Binary Eq (Var IntS "v0") (Var IntS "v1")])], validConstraints = fromList [Binary Implies (Unknown (fromList [("v0",Var IntS "v2"),("v1",Var IntS "v3")]) "$k0") (Binary Eq (Func BoolS "bar" [Var IntS "v2"]) (Func BoolS "bar" [Var IntS "v3"]))], invalidConstraints = fromList [], label = "0.1"}]


Final candidates:
0.0: [$k0 -> {v1 [37m==[0m v0}] (1 0)
0.1: [$k0 -> {v0 [37m==[0m v1}] (1 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/gfp00.smt2
Qualifier "Pos" [Var IntS "v"] (Binary Le (IntLit 0) (Var IntS "v"))
Qualifier "Neg" [Var IntS "v"] (Binary Le (Var IntS "v") (IntLit 0))
Qualifier "NeqZ" [Var IntS "v"] (Unary Not (Binary Eq (Var IntS "v") (IntLit 0)))
Qualifier "False" [] (Binary Eq (IntLit 66) (IntLit 77))
WFConstraint "$k0" [Var IntS "v0"]
HornConstraint [Var IntS "v1"] (Binary Implies (Unknown (fromList [("v0",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))))
HornConstraint [Var IntS "v2"] (Binary Implies (Binary Eq (Var IntS "v2") (IntLit 10)) (Unknown (fromList [("v0",Var IntS "v2")]) "$k0"))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Le (IntLit 0) (Var IntS "v0"),Binary Le (Var IntS "v0") (IntLit 0),Unary Not (Binary Eq (Var IntS "v0") (IntLit 0)),Binary Eq (IntLit 66) (IntLit 77)], _maxCount = 4})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Le (IntLit 0) (Var IntS "v0")])], validConstraints = fromList [Binary Implies (Unknown (fromList [("v0",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))),Binary Implies (Binary Eq (Var IntS "v2") (IntLit 10)) (Unknown (fromList [("v0",Var IntS "v2")]) "$k0")], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {[36m0[0m [37m<=[0m v0}] (2 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/gfp02.smt2
Qualifier "Pos" [Var IntS "v"] (Binary Le (IntLit 0) (Var IntS "v"))
Qualifier "Neg" [Var IntS "v"] (Binary Le (Var IntS "v") (IntLit 0))
Qualifier "NeqZ" [Var IntS "v"] (Unary Not (Binary Eq (Var IntS "v") (IntLit 0)))
Qualifier "GtTen" [Var IntS "v"] (Binary Lt (Var IntS "v") (IntLit 10))
Qualifier "False" [] (Binary Eq (IntLit 66) (IntLit 77))
WFConstraint "$k0" [Var IntS "v0"]
HornConstraint [Var IntS "v1"] (Binary Implies (Unknown (fromList [("v0",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))))
HornConstraint [Var IntS "v3"] (Binary Implies (Unknown (fromList [("v0",Var IntS "v3")]) "$k0") (Binary Gt (IntLit 11) (Binary Plus (Var IntS "v3") (IntLit 1))))
HornConstraint [Var IntS "v2"] (Binary Implies (Binary Eq (Var IntS "v2") (IntLit 9)) (Unknown (fromList [("v0",Var IntS "v2")]) "$k0"))
HornConstraint [Var IntS "v4"] (Binary Implies (Binary And (Binary Lt (Var IntS "v4") (IntLit 9)) (Binary Gt (Var IntS "v4") (IntLit 3))) (Unknown (fromList [("v0",Var IntS "v4")]) "$k0"))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Le (IntLit 0) (Var IntS "v0"),Binary Le (Var IntS "v0") (IntLit 0),Unary Not (Binary Eq (Var IntS "v0") (IntLit 0)),Binary Lt (Var IntS "v0") (IntLit 10),Binary Eq (IntLit 66) (IntLit 77)], _maxCount = 5})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Lt (Var IntS "v0") (IntLit 10),Binary Le (IntLit 0) (Var IntS "v0")])], validConstraints = fromList [Binary Implies (Unknown (fromList [("v0",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))),Binary Implies (Unknown (fromList [("v0",Var IntS "v3")]) "$k0") (Binary Gt (IntLit 11) (Binary Plus (Var IntS "v3") (IntLit 1))),Binary Implies (Binary Eq (Var IntS "v2") (IntLit 9)) (Unknown (fromList [("v0",Var IntS "v2")]) "$k0"),Binary Implies (Binary And (Binary Lt (Var IntS "v4") (IntLit 9)) (Binary Gt (Var IntS "v4") (IntLit 3))) (Unknown (fromList [("v0",Var IntS "v4")]) "$k0")], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {v0 [37m<[0m [36m10[0m, [36m0[0m [37m<=[0m v0}] (4 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/gfp03.smt2
Qualifier "Pos" [Var IntS "v"] (Binary Le (IntLit 0) (Var IntS "v"))
Qualifier "Neg" [Var IntS "v"] (Binary Le (Var IntS "v") (IntLit 0))
Qualifier "NeqZ" [Var IntS "v"] (Unary Not (Binary Eq (Var IntS "v") (IntLit 0)))
Qualifier "GtTen" [Var IntS "v"] (Binary Lt (Var IntS "v") (IntLit 10))
Qualifier "False" [] (Binary Eq (IntLit 66) (IntLit 77))
WFConstraint "$k0" [Var IntS "b1"]
HornConstraint [Var IntS "v1"] (Binary Implies (Unknown (fromList [("b1",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))))
HornConstraint [Var IntS "v3"] (Binary Implies (Unknown (fromList [("b1",Var IntS "v3")]) "$k0") (Binary Gt (IntLit 11) (Binary Plus (Var IntS "v3") (IntLit 1))))
HornConstraint [Var IntS "v2"] (Binary Implies (Binary Eq (Var IntS "v2") (IntLit 9)) (Unknown (fromList [("b1",Var IntS "v2")]) "$k0"))
HornConstraint [Var IntS "v4"] (Binary Implies (Binary And (Binary Lt (Var IntS "v4") (IntLit 9)) (Binary Gt (Var IntS "v4") (IntLit 3))) (Unknown (fromList [("b1",Var IntS "v4")]) "$k0"))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Le (IntLit 0) (Var IntS "b1"),Binary Le (Var IntS "b1") (IntLit 0),Unary Not (Binary Eq (Var IntS "b1") (IntLit 0)),Binary Lt (Var IntS "b1") (IntLit 10),Binary Eq (IntLit 66) (IntLit 77)], _maxCount = 5})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Lt (Var IntS "b1") (IntLit 10),Binary Le (IntLit 0) (Var IntS "b1")])], validConstraints = fromList [Binary Implies (Unknown (fromList [("b1",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))),Binary Implies (Unknown (fromList [("b1",Var IntS "v3")]) "$k0") (Binary Gt (IntLit 11) (Binary Plus (Var IntS "v3") (IntLit 1))),Binary Implies (Binary Eq (Var IntS "v2") (IntLit 9)) (Unknown (fromList [("b1",Var IntS "v2")]) "$k0"),Binary Implies (Binary And (Binary Lt (Var IntS "v4") (IntLit 9)) (Binary Gt (Var IntS "v4") (IntLit 3))) (Unknown (fromList [("b1",Var IntS "v4")]) "$k0")], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {b1 [37m<[0m [36m10[0m, [36m0[0m [37m<=[0m b1}] (4 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/len00.smt2
SortDecl "Tuple" 2
UninterpFunction "len" [SetS (VarS "1")] IntS
Qualifier "ListZ" [Var (SetS (VarS "0")) "v"] (Binary Ge (Func IntS "len" [Var (SetS (VarS "1")) "v"]) (IntLit 0))
WFConstraint "$k0" [Var (SetS (DataS "Tuple" [IntS,VarS "a"])) "v"]
HornConstraint [Var (SetS (DataS "Tuple" [IntS,VarS "a"])) "v"] (Binary Implies (Binary Ge (Func IntS "len" [Var (SetS (DataS "Tuple" [IntS,VarS "a"])) "v"]) (IntLit 0)) (Unknown (fromList [("v",Var (SetS (DataS "Tuple" [IntS,VarS "a"])) "v")]) "$k0"))
HornConstraint [Var (SetS (DataS "Tuple" [IntS,VarS "a"])) "v"] (Binary Implies (Unknown (fromList [("v",Var (SetS (DataS "Tuple" [IntS,VarS "a"])) "v")]) "$k0") (Binary Ge (Func IntS "len" [Var (SetS (DataS "Tuple" [IntS,VarS "a"])) "v"]) (IntLit 0)))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [], _maxCount = 0})]

Candidates
--------
[]


Final candidates:
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/map_sanity.smt2
Qualifier "Equiv" [Var (VarS "a") "v",Var (VarS "b") "z"] (Binary Eq (Var (VarS "a") "v") (Var (VarS "b") "z"))
Qualifier "False" [Var (VarS "a") "a",Var (VarS "b") "b"] (BoolLit False)
WFConstraint "$k0" [Var IntS "v",Var IntS "x"]
HornConstraint [Var IntS "v",Var IntS "q",Var (MapS IntS IntS) "m1"] (Binary Implies (Binary And (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m1") (IntLit 100))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var IntS "q") (IntLit 0))) (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "q")]) "$k0"))
HornConstraint [Var (MapS BoolS BoolS) "m1"] (Binary Implies (Binary Eq (Var (MapS BoolS BoolS) "m1") (MapLit BoolS (BoolLit True))) (Binary Eq (MapSel (Var (MapS BoolS BoolS) "m1") (BoolLit False)) (BoolLit True)))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Eq (Var IntS "v") (Var IntS "x"),Binary Eq (Var IntS "x") (Var IntS "v"),BoolLit False], _maxCount = 3})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [])], validConstraints = fromList [Binary Implies (Binary Eq (Var (MapS BoolS BoolS) "m1") (MapLit BoolS (BoolLit True))) (Binary Eq (MapSel (Var (MapS BoolS BoolS) "m1") (BoolLit False)) (BoolLit True)),Binary Implies (Binary And (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m1") (IntLit 100))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var IntS "q") (IntLit 0))) (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "q")]) "$k0")], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {}] (2 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/maps.smt2
HornConstraint [Var IntS "v",Var (MapS IntS IntS) "m1"] (Binary Implies (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m1") (IntLit 100))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var IntS "v") (IntLit 0)))
HornConstraint [Var IntS "v",Var (MapS IntS IntS) "m1",Var (MapS IntS IntS) "m2"] (Binary Implies (Binary And (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m2") (IntLit 100))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1)))) (Binary Eq (Var IntS "v") (IntLit 0)))
HornConstraint [Var IntS "v",Var (MapS IntS IntS) "m1",Var (MapS IntS IntS) "m2"] (Binary Implies (Binary And (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m2") (IntLit 10))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1)))) (Binary Eq (Var IntS "v") (IntLit 1)))
HornConstraint [Var IntS "v",Var (MapS IntS IntS) "m1",Var (MapS IntS IntS) "m2",Var (MapS IntS IntS) "m3"] (Binary Implies (Binary And (Binary And (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1)))) (Binary Eq (Var (MapS IntS IntS) "m3") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 20) (IntLit 1)) (IntLit 10) (IntLit 1)))) (Binary Eq (Var (MapS IntS IntS) "m2") (Var (MapS IntS IntS) "m3")))

QMAP
--------
fromList []

Candidates
--------
[Candidate {solution = fromList [], validConstraints = fromList [Binary Implies (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m1") (IntLit 100))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var IntS "v") (IntLit 0)),Binary Implies (Binary And (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m2") (IntLit 10))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1)))) (Binary Eq (Var IntS "v") (IntLit 1)),Binary Implies (Binary And (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m2") (IntLit 100))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1)))) (Binary Eq (Var IntS "v") (IntLit 0)),Binary Implies (Binary And (Binary And (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1)))) (Binary Eq (Var (MapS IntS IntS) "m3") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 20) (IntLit 1)) (IntLit 10) (IntLit 1)))) (Binary Eq (Var (MapS IntS IntS) "m2") (Var (MapS IntS IntS) "m3"))], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [] (4 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/nadia.smt2
SortDecl "List" 1
UninterpFunction "len" [DataS "List" [VarS "0"]] IntS
UninterpFunction "elems" [DataS "List" [VarS "0"]] (SetS (VarS "0"))
Qualifier "LenZ" [Var (DataS "List" [VarS "0"]) "x"] (Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "x"]) (IntLit 0))
Qualifier "Empty" [Var (DataS "List" [VarS "0"]) "x"] (Binary Eq (Func (SetS (VarS "0")) "elems" [Var (DataS "List" [VarS "0"]) "x"]) (SetLit (VarS "0") []))
Qualifier "Plus1" [Var (DataS "List" [VarS "0"]) "x",Var (DataS "List" [VarS "0"]) "y"] (Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "x"]) (Binary Plus (IntLit 1) (Func IntS "len" [Var (DataS "List" [VarS "0"]) "y"])))
Qualifier "SumL" [Var (DataS "List" [VarS "0"]) "x",Var (DataS "List" [VarS "0"]) "y",Var (VarS "0") "z"] (Binary Eq (Func (SetS (VarS "_a")) "elems" [Var (DataS "List" [VarS "0"]) "x"]) (Binary Union (SetLit (VarS "_a") [Var (VarS "0") "z"]) (Func (SetS (VarS "_a")) "elems" [Var (DataS "List" [VarS "0"]) "y"])))
WFConstraint "$k0" [Var (DataS "List" [VarS "0"]) "nil",Var (DataS "List" [VarS "0"]) "v0",Var IntS "v1"]
HornConstraint [Var IntS "x",Var (DataS "List" [VarS "0"]) "nil",Var (DataS "List" [VarS "0"]) "x4",Var (DataS "List" [VarS "0"]) "_v"] (Binary Implies (Binary And (Binary And (Binary And (Binary And (Binary Eq (Func (SetS (VarS "0")) "elems" [Var (DataS "List" [VarS "0"]) "nil"]) (SetLit (VarS "0") [])) (Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "nil"]) (IntLit 0))) (Unknown (fromList [("nil",Var (DataS "List" [VarS "0"]) "nil"),("v0",Var (DataS "List" [VarS "0"]) "x4"),("v1",Var IntS "x")]) "$k0")) (Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "_v"]) (Binary Plus (IntLit 1) (Func IntS "len" [Var (DataS "List" [VarS "0"]) "x4"])))) (Binary Ge (Func IntS "len" [Var (DataS "List" [VarS "0"]) "x4"]) (IntLit 0))) (Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "_v"]) (IntLit 2)))
HornConstraint [Var IntS "x",Var (DataS "List" [VarS "0"]) "nil",Var (DataS "List" [VarS "0"]) "x4",Var (DataS "List" [VarS "0"]) "_v"] (Binary Implies (Binary And (Binary And (Binary And (Binary And (Binary Eq (Func (SetS (VarS "0")) "elems" [Var (DataS "List" [VarS "0"]) "nil"]) (SetLit (VarS "0") [])) (Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "nil"]) (IntLit 0))) (Unknown (fromList [("nil",Var (DataS "List" [VarS "0"]) "nil"),("v0",Var (DataS "List" [VarS "0"]) "x4"),("v1",Var IntS "x")]) "$k0")) (Binary Eq (Func (SetS (VarS "_a")) "elems" [Var (DataS "List" [VarS "0"]) "_v"]) (Binary Union (SetLit IntS [Var IntS "x"]) (Func (SetS (VarS "_a")) "elems" [Var (DataS "List" [VarS "0"]) "x4"])))) (Binary Ge (Func IntS "len" [Var (DataS "List" [VarS "0"]) "x4"]) (IntLit 0))) (Binary Eq (Func (SetS IntS) "elems" [Var (DataS "List" [VarS "0"]) "_v"]) (SetLit IntS [Var IntS "x"])))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "nil"]) (IntLit 0),Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "v0"]) (IntLit 0),Binary Eq (Func (SetS (VarS "0")) "elems" [Var (DataS "List" [VarS "0"]) "nil"]) (SetLit (VarS "0") []),Binary Eq (Func (SetS (VarS "0")) "elems" [Var (DataS "List" [VarS "0"]) "v0"]) (SetLit (VarS "0") []),Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "nil"]) (Binary Plus (IntLit 1) (Func IntS "len" [Var (DataS "List" [VarS "0"]) "v0"])),Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "v0"]) (Binary Plus (IntLit 1) (Func IntS "len" [Var (DataS "List" [VarS "0"]) "nil"])),Binary Eq (Func (SetS (VarS "_a")) "elems" [Var (DataS "List" [VarS "0"]) "nil"]) (Binary Union (SetLit (VarS "_a") [Var IntS "v1"]) (Func (SetS (VarS "_a")) "elems" [Var (DataS "List" [VarS "0"]) "v0"])),Binary Eq (Func (SetS (VarS "_a")) "elems" [Var (DataS "List" [VarS "0"]) "v0"]) (Binary Union (SetLit (VarS "_a") [Var IntS "v1"]) (Func (SetS (VarS "_a")) "elems" [Var (DataS "List" [VarS "0"]) "nil"]))], _maxCount = 8})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "v0"]) (Binary Plus (IntLit 1) (Func IntS "len" [Var (DataS "List" [VarS "0"]) "nil"])),Binary Eq (Func (SetS (VarS "0")) "elems" [Var (DataS "List" [VarS "0"]) "v0"]) (SetLit (VarS "0") [])])], validConstraints = fromList [Binary Implies (Binary And (Binary And (Binary And (Binary And (Binary Eq (Func (SetS (VarS "0")) "elems" [Var (DataS "List" [VarS "0"]) "nil"]) (SetLit (VarS "0") [])) (Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "nil"]) (IntLit 0))) (Unknown (fromList [("nil",Var (DataS "List" [VarS "0"]) "nil"),("v0",Var (DataS "List" [VarS "0"]) "x4"),("v1",Var IntS "x")]) "$k0")) (Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "_v"]) (Binary Plus (IntLit 1) (Func IntS "len" [Var (DataS "List" [VarS "0"]) "x4"])))) (Binary Ge (Func IntS "len" [Var (DataS "List" [VarS "0"]) "x4"]) (IntLit 0))) (Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "_v"]) (IntLit 2)),Binary Implies (Binary And (Binary And (Binary And (Binary And (Binary Eq (Func (SetS (VarS "0")) "elems" [Var (DataS "List" [VarS "0"]) "nil"]) (SetLit (VarS "0") [])) (Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "nil"]) (IntLit 0))) (Unknown (fromList [("nil",Var (DataS "List" [VarS "0"]) "nil"),("v0",Var (DataS "List" [VarS "0"]) "x4"),("v1",Var IntS "x")]) "$k0")) (Binary Eq (Func (SetS (VarS "_a")) "elems" [Var (DataS "List" [VarS "0"]) "_v"]) (Binary Union (SetLit IntS [Var IntS "x"]) (Func (SetS (VarS "_a")) "elems" [Var (DataS "List" [VarS "0"]) "x4"])))) (Binary Ge (Func IntS "len" [Var (DataS "List" [VarS "0"]) "x4"]) (IntLit 0))) (Binary Eq (Func (SetS IntS) "elems" [Var (DataS "List" [VarS "0"]) "_v"]) (SetLit IntS [Var IntS "x"]))], invalidConstraints = fromList [], label = "0.0"},Candidate {solution = fromList [("$k0",fromList [Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "v0"]) (Binary Plus (IntLit 1) (Func IntS "len" [Var (DataS "List" [VarS "0"]) "nil"])),Binary Eq (Func (SetS (VarS "_a")) "elems" [Var (DataS "List" [VarS "0"]) "v0"]) (Binary Union (SetLit (VarS "_a") [Var IntS "v1"]) (Func (SetS (VarS "_a")) "elems" [Var (DataS "List" [VarS "0"]) "nil"]))])], validConstraints = fromList [Binary Implies (Binary And (Binary And (Binary And (Binary And (Binary Eq (Func (SetS (VarS "0")) "elems" [Var (DataS "List" [VarS "0"]) "nil"]) (SetLit (VarS "0") [])) (Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "nil"]) (IntLit 0))) (Unknown (fromList [("nil",Var (DataS "List" [VarS "0"]) "nil"),("v0",Var (DataS "List" [VarS "0"]) "x4"),("v1",Var IntS "x")]) "$k0")) (Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "_v"]) (Binary Plus (IntLit 1) (Func IntS "len" [Var (DataS "List" [VarS "0"]) "x4"])))) (Binary Ge (Func IntS "len" [Var (DataS "List" [VarS "0"]) "x4"]) (IntLit 0))) (Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "_v"]) (IntLit 2)),Binary Implies (Binary And (Binary And (Binary And (Binary And (Binary Eq (Func (SetS (VarS "0")) "elems" [Var (DataS "List" [VarS "0"]) "nil"]) (SetLit (VarS "0") [])) (Binary Eq (Func IntS "len" [Var (DataS "List" [VarS "0"]) "nil"]) (IntLit 0))) (Unknown (fromList [("nil",Var (DataS "List" [VarS "0"]) "nil"),("v0",Var (DataS "List" [VarS "0"]) "x4"),("v1",Var IntS "x")]) "$k0")) (Binary Eq (Func (SetS (VarS "_a")) "elems" [Var (DataS "List" [VarS "0"]) "_v"]) (Binary Union (SetLit IntS [Var IntS "x"]) (Func (SetS (VarS "_a")) "elems" [Var (DataS "List" [VarS "0"]) "x4"])))) (Binary Ge (Func IntS "len" [Var (DataS "List" [VarS "0"]) "x4"]) (IntLit 0))) (Binary Eq (Func (SetS IntS) "elems" [Var (DataS "List" [VarS "0"]) "_v"]) (SetLit IntS [Var IntS "x"]))], invalidConstraints = fromList [], label = "0.1"}]


Final candidates:
0.0: [$k0 -> {len v0 [37m==[0m [36m1[0m [37m+[0m len nil, elems v0 [37m==[0m [37m[[0m[37m][0m}] (2 0)
0.1: [$k0 -> {len v0 [37m==[0m [36m1[0m [37m+[0m len nil, elems v0 [37m==[0m [37m[[0mv1[37m][0m [37m+[0m elems nil}] (2 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/qmap0.smt2
Qualifier "Discard" [Var BoolS "b"] (Binary Eq (Var BoolS "b") (Var BoolS "b"))
Qualifier "Accept" [Var IntS "v"] (Binary Le (Var IntS "v") (IntLit 0))
WFConstraint "$k0" [Var IntS "v0"]
WFConstraint "$k1" [Var BoolS "b0"]
WFConstraint "$k2" [Var IntS "v1",Var BoolS "b1"]

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Le (Var IntS "v0") (IntLit 0)], _maxCount = 1}),("$k1",QSpace {_qualifiers = [Binary Eq (Var BoolS "b0") (Var BoolS "b0")], _maxCount = 1}),("$k2",QSpace {_qualifiers = [Binary Eq (Var BoolS "b1") (Var BoolS "b1"),Binary Le (Var IntS "v1") (IntLit 0)], _maxCount = 2})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList []),("$k1",fromList []),("$k2",fromList [])], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {}, $k1 -> {}, $k2 -> {}] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/qmap1a.smt2
Qualifier "Less" [Var IntS "a",Var IntS "b"] (Binary Lt (Var IntS "a") (Var IntS "b"))
WFConstraint "$k0" [Var IntS "v0",Var IntS "v1"]

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Lt (Var IntS "v0") (Var IntS "v1"),Binary Lt (Var IntS "v1") (Var IntS "v0")], _maxCount = 2})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [])], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {}] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/qmap1b.smt2
Qualifier "Sum" [Var IntS "a",Var IntS "b",Var IntS "c"] (Binary Eq (Binary Plus (Var IntS "a") (Var IntS "b")) (Var IntS "c"))
WFConstraint "$k0" [Var IntS "v0",Var IntS "v1",Var IntS "v2"]

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Eq (Binary Plus (Var IntS "v0") (Var IntS "v1")) (Var IntS "v2"),Binary Eq (Binary Plus (Var IntS "v0") (Var IntS "v2")) (Var IntS "v1"),Binary Eq (Binary Plus (Var IntS "v1") (Var IntS "v0")) (Var IntS "v2"),Binary Eq (Binary Plus (Var IntS "v1") (Var IntS "v2")) (Var IntS "v0"),Binary Eq (Binary Plus (Var IntS "v2") (Var IntS "v0")) (Var IntS "v1"),Binary Eq (Binary Plus (Var IntS "v2") (Var IntS "v1")) (Var IntS "v0")], _maxCount = 6})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [])], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {}] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/qmap2.smt2
Qualifier "Less" [Var IntS "a",Var IntS "b"] (Binary Lt (Var IntS "a") (Var IntS "b"))
Qualifier "Or" [Var BoolS "a",Var BoolS "b"] (Binary Or (Var BoolS "a") (Var BoolS "b"))
WFConstraint "$k0" [Var IntS "v0",Var IntS "v1"]
WFConstraint "$k1" [Var BoolS "v0",Var BoolS "v1"]

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Lt (Var IntS "v0") (Var IntS "v1"),Binary Lt (Var IntS "v1") (Var IntS "v0")], _maxCount = 2}),("$k1",QSpace {_qualifiers = [Binary Or (Var BoolS "v0") (Var BoolS "v1"),Binary Or (Var BoolS "v1") (Var BoolS "v0")], _maxCount = 2})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList []),("$k1",fromList [])], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {}, $k1 -> {}] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/sets01.smt2
HornConstraint [Var IntS "v",Var (SetS IntS) "m1"] (Binary Implies (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Unary Not (Binary Member (IntLit 100) (Var (SetS IntS) "m1"))))
HornConstraint [Var IntS "v",Var (SetS IntS) "m1",Var (SetS IntS) "m2"] (Binary Implies (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 10])) (SetLit IntS [IntLit 20])))) (Unary Not (Binary Member (IntLit 100) (Var (SetS IntS) "m2"))))
HornConstraint [Var IntS "v",Var (SetS IntS) "m1",Var (SetS IntS) "m2"] (Binary Implies (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 10])) (SetLit IntS [IntLit 20])))) (Binary Member (IntLit 10) (Var (SetS IntS) "m2")))
HornConstraint [Var IntS "v",Var (SetS IntS) "m1",Var (SetS IntS) "m2",Var (SetS IntS) "m3"] (Binary Implies (Binary And (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 10])) (SetLit IntS [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m3") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 20])) (SetLit IntS [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m2") (Var (SetS IntS) "m3")))
HornConstraint [Var IntS "v",Var (SetS IntS) "m1",Var (SetS IntS) "m2",Var (SetS IntS) "m3",Var (SetS IntS) "m4",Var (SetS IntS) "m5"] (Binary Implies (Binary And (Binary And (Binary And (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 10])) (SetLit IntS [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m3") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 20])) (SetLit IntS [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m4") (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m5") (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m2") (Var (SetS IntS) "m3")))

QMAP
--------
fromList []

Candidates
--------
[Candidate {solution = fromList [], validConstraints = fromList [Binary Implies (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Unary Not (Binary Member (IntLit 100) (Var (SetS IntS) "m1"))),Binary Implies (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 10])) (SetLit IntS [IntLit 20])))) (Unary Not (Binary Member (IntLit 100) (Var (SetS IntS) "m2"))),Binary Implies (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 10])) (SetLit IntS [IntLit 20])))) (Binary Member (IntLit 10) (Var (SetS IntS) "m2")),Binary Implies (Binary And (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 10])) (SetLit IntS [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m3") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 20])) (SetLit IntS [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m2") (Var (SetS IntS) "m3")),Binary Implies (Binary And (Binary And (Binary And (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 10])) (SetLit IntS [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m3") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 20])) (SetLit IntS [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m4") (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m5") (Binary Union (Var (SetS IntS) "m1") (SetLit IntS [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m2") (Var (SetS IntS) "m3"))], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [] (5 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/test3.smt2
Qualifier "Zog" [Var (VarS "a") "v",Var (VarS "b") "z"] (Binary Eq (Var (VarS "a") "v") (Var (VarS "b") "z"))
WFConstraint "$k0" [Var IntS "v",Var IntS "x"]
HornConstraint [Var IntS "v",Var IntS "q"] (Binary Implies (Binary Eq (Var IntS "v") (Var IntS "q")) (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "q")]) "$k0"))
HornConstraint [Var IntS "v",Var IntS "y"] (Binary Implies (Binary And (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "y")]) "$k0") (Binary Eq (Var IntS "y") (IntLit 10))) (Binary Eq (Var IntS "v") (IntLit 10)))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Eq (Var IntS "v") (Var IntS "x"),Binary Eq (Var IntS "x") (Var IntS "v")], _maxCount = 2})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Eq (Var IntS "x") (Var IntS "v")])], validConstraints = fromList [Binary Implies (Binary Eq (Var IntS "v") (Var IntS "q")) (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "q")]) "$k0"),Binary Implies (Binary And (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "y")]) "$k0") (Binary Eq (Var IntS "y") (IntLit 10))) (Binary Eq (Var IntS "v") (IntLit 10))], invalidConstraints = fromList [], label = "0.0"},Candidate {solution = fromList [("$k0",fromList [Binary Eq (Var IntS "v") (Var IntS "x")])], validConstraints = fromList [Binary Implies (Binary Eq (Var IntS "v") (Var IntS "q")) (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "q")]) "$k0"),Binary Implies (Binary And (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "y")]) "$k0") (Binary Eq (Var IntS "y") (IntLit 10))) (Binary Eq (Var IntS "v") (IntLit 10))], invalidConstraints = fromList [], label = "0.1"}]


Final candidates:
0.0: [$k0 -> {x [37m==[0m v}] (2 0)
0.1: [$k0 -> {v [37m==[0m x}] (2 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/unary0.smt2
Qualifier "Neg" [Var IntS "i"] (Unary Neg (Var IntS "i"))
Qualifier "Not" [Var BoolS "b"] (Unary Not (Var BoolS "b"))

QMAP
--------
fromList []

Candidates
--------
[Candidate {solution = fromList [], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/var00.smt2
WFConstraint "$k0" [Var IntS "_v",Var IntS "x"]

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [], _maxCount = 0})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [])], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {}] (0 0)
