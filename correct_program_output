Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/binary0.smt2
Qualifier "Pos" [Var IntS "v"] (Binary Le (IntLit 0) (Var IntS "v"))
Qualifier "Neg" [Var IntS "v"] (Binary Le (Var IntS "v") (IntLit 0))

QMAP
--------
fromList []

Candidates
--------
[Candidate {solution = fromList [], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/func0.smt2
Qualifier "Eq" [Var AnyS "v",Var AnyS "z"] (Binary Eq (Var AnyS "v") (Var AnyS "z"))
UninterpFunction "bar" [IntS] BoolS
WFConstraint "$k0" [Var IntS "v0",Var IntS "v1"]
HornConstraint [Var IntS "v2",Var IntS "v3"] (Binary Implies (Unknown (fromList [("v0",Var IntS "v2"),("v1",Var IntS "v3")]) "$k0") (Binary Eq (Func BoolS "bar" [Var IntS "v2"]) (Func BoolS "bar" [Var IntS "v3"])))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Eq (Var IntS "v0") (Var IntS "v1"),Binary Eq (Var IntS "v1") (Var IntS "v0")], _maxCount = 2})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Eq (Var IntS "v1") (Var IntS "v0")])], validConstraints = fromList [Binary Implies (Unknown (fromList [("v0",Var IntS "v2"),("v1",Var IntS "v3")]) "$k0") (Binary Eq (Func BoolS "bar" [Var IntS "v2"]) (Func BoolS "bar" [Var IntS "v3"]))], invalidConstraints = fromList [], label = "0.0"},Candidate {solution = fromList [("$k0",fromList [Binary Eq (Var IntS "v0") (Var IntS "v1")])], validConstraints = fromList [Binary Implies (Unknown (fromList [("v0",Var IntS "v2"),("v1",Var IntS "v3")]) "$k0") (Binary Eq (Func BoolS "bar" [Var IntS "v2"]) (Func BoolS "bar" [Var IntS "v3"]))], invalidConstraints = fromList [], label = "0.1"}]


Final candidates:
0.0: [$k0 -> {v1 [37m==[0m v0}] (1 0)
0.1: [$k0 -> {v0 [37m==[0m v1}] (1 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/gfp00.smt2
Qualifier "Pos" [Var IntS "v"] (Binary Le (IntLit 0) (Var IntS "v"))
Qualifier "Neg" [Var IntS "v"] (Binary Le (Var IntS "v") (IntLit 0))
Qualifier "NeqZ" [Var IntS "v"] (Unary Not (Binary Eq (Var IntS "v") (IntLit 0)))
Qualifier "False" [] (Binary Eq (IntLit 66) (IntLit 77))
WFConstraint "$k0" [Var IntS "v0"]
HornConstraint [Var IntS "v1"] (Binary Implies (Unknown (fromList [("v0",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))))
HornConstraint [Var IntS "v2"] (Binary Implies (Binary Eq (Var IntS "v2") (IntLit 10)) (Unknown (fromList [("v0",Var IntS "v2")]) "$k0"))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Le (IntLit 0) (Var IntS "v0"),Binary Le (Var IntS "v0") (IntLit 0),Unary Not (Binary Eq (Var IntS "v0") (IntLit 0)),Binary Eq (IntLit 66) (IntLit 77)], _maxCount = 4})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Le (IntLit 0) (Var IntS "v0")])], validConstraints = fromList [Binary Implies (Unknown (fromList [("v0",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))),Binary Implies (Binary Eq (Var IntS "v2") (IntLit 10)) (Unknown (fromList [("v0",Var IntS "v2")]) "$k0")], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {[36m0[0m [37m<=[0m v0}] (2 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/gfp02.smt2
Qualifier "Pos" [Var IntS "v"] (Binary Le (IntLit 0) (Var IntS "v"))
Qualifier "Neg" [Var IntS "v"] (Binary Le (Var IntS "v") (IntLit 0))
Qualifier "NeqZ" [Var IntS "v"] (Unary Not (Binary Eq (Var IntS "v") (IntLit 0)))
Qualifier "GtTen" [Var IntS "v"] (Binary Lt (Var IntS "v") (IntLit 10))
Qualifier "False" [] (Binary Eq (IntLit 66) (IntLit 77))
WFConstraint "$k0" [Var IntS "v0"]
HornConstraint [Var IntS "v1"] (Binary Implies (Unknown (fromList [("v0",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))))
HornConstraint [Var IntS "v3"] (Binary Implies (Unknown (fromList [("v0",Var IntS "v3")]) "$k0") (Binary Gt (IntLit 11) (Binary Plus (Var IntS "v3") (IntLit 1))))
HornConstraint [Var IntS "v2"] (Binary Implies (Binary Eq (Var IntS "v2") (IntLit 9)) (Unknown (fromList [("v0",Var IntS "v2")]) "$k0"))
HornConstraint [Var IntS "v4"] (Binary Implies (Binary And (Binary Lt (Var IntS "v4") (IntLit 9)) (Binary Gt (Var IntS "v4") (IntLit 3))) (Unknown (fromList [("v0",Var IntS "v4")]) "$k0"))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Le (IntLit 0) (Var IntS "v0"),Binary Le (Var IntS "v0") (IntLit 0),Unary Not (Binary Eq (Var IntS "v0") (IntLit 0)),Binary Lt (Var IntS "v0") (IntLit 10),Binary Eq (IntLit 66) (IntLit 77)], _maxCount = 5})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Lt (Var IntS "v0") (IntLit 10),Binary Le (IntLit 0) (Var IntS "v0")])], validConstraints = fromList [Binary Implies (Unknown (fromList [("v0",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))),Binary Implies (Unknown (fromList [("v0",Var IntS "v3")]) "$k0") (Binary Gt (IntLit 11) (Binary Plus (Var IntS "v3") (IntLit 1))),Binary Implies (Binary Eq (Var IntS "v2") (IntLit 9)) (Unknown (fromList [("v0",Var IntS "v2")]) "$k0"),Binary Implies (Binary And (Binary Lt (Var IntS "v4") (IntLit 9)) (Binary Gt (Var IntS "v4") (IntLit 3))) (Unknown (fromList [("v0",Var IntS "v4")]) "$k0")], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {v0 [37m<[0m [36m10[0m, [36m0[0m [37m<=[0m v0}] (4 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/gfp03.smt2
Qualifier "Pos" [Var IntS "v"] (Binary Le (IntLit 0) (Var IntS "v"))
Qualifier "Neg" [Var IntS "v"] (Binary Le (Var IntS "v") (IntLit 0))
Qualifier "NeqZ" [Var IntS "v"] (Unary Not (Binary Eq (Var IntS "v") (IntLit 0)))
Qualifier "GtTen" [Var IntS "v"] (Binary Lt (Var IntS "v") (IntLit 10))
Qualifier "False" [] (Binary Eq (IntLit 66) (IntLit 77))
WFConstraint "$k0" [Var IntS "b1"]
HornConstraint [Var IntS "v1"] (Binary Implies (Unknown (fromList [("b1",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))))
HornConstraint [Var IntS "v3"] (Binary Implies (Unknown (fromList [("b1",Var IntS "v3")]) "$k0") (Binary Gt (IntLit 11) (Binary Plus (Var IntS "v3") (IntLit 1))))
HornConstraint [Var IntS "v2"] (Binary Implies (Binary Eq (Var IntS "v2") (IntLit 9)) (Unknown (fromList [("b1",Var IntS "v2")]) "$k0"))
HornConstraint [Var IntS "v4"] (Binary Implies (Binary And (Binary Lt (Var IntS "v4") (IntLit 9)) (Binary Gt (Var IntS "v4") (IntLit 3))) (Unknown (fromList [("b1",Var IntS "v4")]) "$k0"))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Le (IntLit 0) (Var IntS "b1"),Binary Le (Var IntS "b1") (IntLit 0),Unary Not (Binary Eq (Var IntS "b1") (IntLit 0)),Binary Lt (Var IntS "b1") (IntLit 10),Binary Eq (IntLit 66) (IntLit 77)], _maxCount = 5})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Lt (Var IntS "b1") (IntLit 10),Binary Le (IntLit 0) (Var IntS "b1")])], validConstraints = fromList [Binary Implies (Unknown (fromList [("b1",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))),Binary Implies (Unknown (fromList [("b1",Var IntS "v3")]) "$k0") (Binary Gt (IntLit 11) (Binary Plus (Var IntS "v3") (IntLit 1))),Binary Implies (Binary Eq (Var IntS "v2") (IntLit 9)) (Unknown (fromList [("b1",Var IntS "v2")]) "$k0"),Binary Implies (Binary And (Binary Lt (Var IntS "v4") (IntLit 9)) (Binary Gt (Var IntS "v4") (IntLit 3))) (Unknown (fromList [("b1",Var IntS "v4")]) "$k0")], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {b1 [37m<[0m [36m10[0m, [36m0[0m [37m<=[0m b1}] (4 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/maps.smt2
HornConstraint [Var IntS "v",Var (MapS IntS IntS) "m1"] (Binary Implies (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m1") (IntLit 100))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit AnyS (IntLit 0)))) (Binary Eq (Var IntS "v") (IntLit 0)))
HornConstraint [Var IntS "v",Var (MapS IntS IntS) "m1",Var (MapS IntS IntS) "m2"] (Binary Implies (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m2") (IntLit 100))) (Binary And (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit AnyS (IntLit 0))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1))))) (Binary Eq (Var IntS "v") (IntLit 0)))
HornConstraint [Var IntS "v",Var (MapS IntS IntS) "m1",Var (MapS IntS IntS) "m2"] (Binary Implies (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m2") (IntLit 10))) (Binary And (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit AnyS (IntLit 0))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1))))) (Binary Eq (Var IntS "v") (IntLit 1)))
HornConstraint [Var IntS "v",Var (MapS IntS IntS) "m1",Var (MapS IntS IntS) "m2",Var (MapS IntS IntS) "m3"] (Binary Implies (Binary And (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit AnyS (IntLit 0))) (Binary And (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1))) (Binary Eq (Var (MapS IntS IntS) "m3") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 20) (IntLit 1)) (IntLit 10) (IntLit 1))))) (Binary Eq (Var (MapS IntS IntS) "m2") (Var (MapS IntS IntS) "m3")))

QMAP
--------
fromList []

Candidates
--------
[Candidate {solution = fromList [], validConstraints = fromList [Binary Implies (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m1") (IntLit 100))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit AnyS (IntLit 0)))) (Binary Eq (Var IntS "v") (IntLit 0)),Binary Implies (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m2") (IntLit 10))) (Binary And (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit AnyS (IntLit 0))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1))))) (Binary Eq (Var IntS "v") (IntLit 1)),Binary Implies (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m2") (IntLit 100))) (Binary And (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit AnyS (IntLit 0))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1))))) (Binary Eq (Var IntS "v") (IntLit 0)),Binary Implies (Binary And (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit AnyS (IntLit 0))) (Binary And (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1))) (Binary Eq (Var (MapS IntS IntS) "m3") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 20) (IntLit 1)) (IntLit 10) (IntLit 1))))) (Binary Eq (Var (MapS IntS IntS) "m2") (Var (MapS IntS IntS) "m3"))], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [] (4 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/qmap0.smt2
Qualifier "Discard" [Var BoolS "b"] (Binary Eq (Var BoolS "b") (Var BoolS "b"))
Qualifier "Partial" [Var IntS "v",Var BoolS "b"] (Unary Not (Binary Eq (Var IntS "v") (Var BoolS "b")))
Qualifier "Accept" [Var IntS "v"] (Binary Le (Var IntS "v") (IntLit 0))
WFConstraint "$k0" [Var IntS "v0"]
WFConstraint "$k1" [Var BoolS "b0"]
WFConstraint "$k2" [Var IntS "v1",Var BoolS "b1"]

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Le (Var IntS "v0") (IntLit 0)], _maxCount = 1}),("$k1",QSpace {_qualifiers = [Binary Eq (Var BoolS "b0") (Var BoolS "b0")], _maxCount = 1}),("$k2",QSpace {_qualifiers = [Binary Eq (Var BoolS "b1") (Var BoolS "b1"),Unary Not (Binary Eq (Var IntS "v1") (Var BoolS "b1")),Binary Le (Var IntS "v1") (IntLit 0)], _maxCount = 3})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList []),("$k1",fromList []),("$k2",fromList [])], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {}, $k1 -> {}, $k2 -> {}] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/qmap1a.smt2
Qualifier "Less" [Var IntS "a",Var IntS "b"] (Binary Lt (Var IntS "a") (Var IntS "b"))
WFConstraint "$k0" [Var IntS "v0",Var IntS "v1"]

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Lt (Var IntS "v0") (Var IntS "v1"),Binary Lt (Var IntS "v1") (Var IntS "v0")], _maxCount = 2})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [])], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {}] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/qmap1b.smt2
Qualifier "Sum" [Var IntS "a",Var IntS "b",Var IntS "c"] (Binary Eq (Binary Plus (Var IntS "a") (Var IntS "b")) (Var IntS "c"))
WFConstraint "$k0" [Var IntS "v0",Var IntS "v1",Var IntS "v2"]

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Eq (Binary Plus (Var IntS "v0") (Var IntS "v1")) (Var IntS "v2"),Binary Eq (Binary Plus (Var IntS "v0") (Var IntS "v2")) (Var IntS "v1"),Binary Eq (Binary Plus (Var IntS "v1") (Var IntS "v0")) (Var IntS "v2"),Binary Eq (Binary Plus (Var IntS "v1") (Var IntS "v2")) (Var IntS "v0"),Binary Eq (Binary Plus (Var IntS "v2") (Var IntS "v0")) (Var IntS "v1"),Binary Eq (Binary Plus (Var IntS "v2") (Var IntS "v1")) (Var IntS "v0")], _maxCount = 6})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [])], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {}] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/qmap2.smt2
Qualifier "Less" [Var IntS "a",Var IntS "b"] (Binary Lt (Var IntS "a") (Var IntS "b"))
Qualifier "Or" [Var BoolS "a",Var BoolS "b"] (Binary Or (Var BoolS "a") (Var BoolS "b"))
WFConstraint "$k0" [Var IntS "v0",Var IntS "v1"]
WFConstraint "$k1" [Var BoolS "v0",Var BoolS "v1"]

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Lt (Var IntS "v0") (Var IntS "v1"),Binary Lt (Var IntS "v1") (Var IntS "v0")], _maxCount = 2}),("$k1",QSpace {_qualifiers = [Binary Or (Var BoolS "v0") (Var BoolS "v1"),Binary Or (Var BoolS "v1") (Var BoolS "v0")], _maxCount = 2})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList []),("$k1",fromList [])], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {}, $k1 -> {}] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sets01.smt2
HornConstraint [Var IntS "v",Var (SetS IntS) "m1"] (Binary Implies (Binary Eq (Var (SetS IntS) "m1") (SetLit AnyS [])) (Unary Not (Binary Member (IntLit 100) (Var (SetS IntS) "m1"))))
HornConstraint [Var IntS "v",Var (SetS IntS) "m1",Var (SetS IntS) "m2"] (Binary Implies (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit AnyS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 10])) (SetLit AnyS [IntLit 20])))) (Unary Not (Binary Member (IntLit 100) (Var (SetS IntS) "m2"))))
HornConstraint [Var IntS "v",Var (SetS IntS) "m1",Var (SetS IntS) "m2"] (Binary Implies (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit AnyS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 10])) (SetLit AnyS [IntLit 20])))) (Binary Member (IntLit 10) (Var (SetS IntS) "m2")))
HornConstraint [Var IntS "v",Var (SetS IntS) "m1",Var (SetS IntS) "m2",Var (SetS IntS) "m3"] (Binary Implies (Binary And (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit AnyS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 10])) (SetLit AnyS [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m3") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 20])) (SetLit AnyS [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m2") (Var (SetS IntS) "m3")))
HornConstraint [Var IntS "v",Var (SetS IntS) "m1",Var (SetS IntS) "m2",Var (SetS IntS) "m3",Var (SetS IntS) "m4",Var (SetS IntS) "m5"] (Binary Implies (Binary And (Binary And (Binary And (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit AnyS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 10])) (SetLit AnyS [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m3") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 20])) (SetLit AnyS [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m4") (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m5") (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m2") (Var (SetS IntS) "m3")))

QMAP
--------
fromList []

Candidates
--------
[Candidate {solution = fromList [], validConstraints = fromList [Binary Implies (Binary Eq (Var (SetS IntS) "m1") (SetLit AnyS [])) (Unary Not (Binary Member (IntLit 100) (Var (SetS IntS) "m1"))),Binary Implies (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit AnyS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 10])) (SetLit AnyS [IntLit 20])))) (Unary Not (Binary Member (IntLit 100) (Var (SetS IntS) "m2"))),Binary Implies (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit AnyS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 10])) (SetLit AnyS [IntLit 20])))) (Binary Member (IntLit 10) (Var (SetS IntS) "m2")),Binary Implies (Binary And (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit AnyS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 10])) (SetLit AnyS [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m3") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 20])) (SetLit AnyS [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m2") (Var (SetS IntS) "m3")),Binary Implies (Binary And (Binary And (Binary And (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit AnyS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 10])) (SetLit AnyS [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m3") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 20])) (SetLit AnyS [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m4") (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m5") (Binary Union (Var (SetS IntS) "m1") (SetLit AnyS [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m2") (Var (SetS IntS) "m3"))], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [] (5 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/test3.smt2
Qualifier "Zog" [Var AnyS "v",Var AnyS "z"] (Binary Eq (Var AnyS "v") (Var AnyS "z"))
WFConstraint "$k0" [Var IntS "v",Var IntS "x"]
HornConstraint [Var IntS "v",Var IntS "q"] (Binary Implies (Binary Eq (Var IntS "v") (Var IntS "q")) (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "q")]) "$k0"))
HornConstraint [Var IntS "v",Var IntS "y"] (Binary Implies (Binary And (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "y")]) "$k0") (Binary Eq (Var IntS "y") (IntLit 10))) (Binary Eq (Var IntS "v") (IntLit 10)))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Eq (Var IntS "v") (Var IntS "x"),Binary Eq (Var IntS "x") (Var IntS "v")], _maxCount = 2})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Eq (Var IntS "x") (Var IntS "v")])], validConstraints = fromList [Binary Implies (Binary Eq (Var IntS "v") (Var IntS "q")) (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "q")]) "$k0"),Binary Implies (Binary And (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "y")]) "$k0") (Binary Eq (Var IntS "y") (IntLit 10))) (Binary Eq (Var IntS "v") (IntLit 10))], invalidConstraints = fromList [], label = "0.0"},Candidate {solution = fromList [("$k0",fromList [Binary Eq (Var IntS "v") (Var IntS "x")])], validConstraints = fromList [Binary Implies (Binary Eq (Var IntS "v") (Var IntS "q")) (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "q")]) "$k0"),Binary Implies (Binary And (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "y")]) "$k0") (Binary Eq (Var IntS "y") (IntLit 10))) (Binary Eq (Var IntS "v") (IntLit 10))], invalidConstraints = fromList [], label = "0.1"}]


Final candidates:
0.0: [$k0 -> {x [37m==[0m v}] (2 0)
0.1: [$k0 -> {v [37m==[0m x}] (2 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/unary0.smt2
Qualifier "Neg" [Var IntS "i"] (Unary Neg (Var IntS "i"))
Qualifier "Not" [Var BoolS "b"] (Unary Not (Var BoolS "b"))

QMAP
--------
fromList []

Candidates
--------
[Candidate {solution = fromList [], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [] (0 0)
