Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/binary0.smt2
Qualifier "Pos" [Var IntS "v"] (Binary Le (IntLit 0) (Var IntS "v"))
Qualifier "Neg" [Var IntS "v"] (Binary Le (Var IntS "v") (IntLit 0))

QMAP
--------
fromList []

Candidates
--------
[Candidate {solution = fromList [], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/func0.smt2
Qualifier "Eq" [Var (VarS "a") "v",Var (VarS "b") "z"] (Binary Eq (Var (VarS "a") "v") (Var (VarS "b") "z"))
UninterpFunction "bar" [IntS] BoolS
WFConstraint "$k0" [Var IntS "v0",Var IntS "v1"]
HornConstraint [Var IntS "v2",Var IntS "v3"] (Binary Implies (Unknown (fromList [("v0",Var IntS "v2"),("v1",Var IntS "v3")]) "$k0") (Binary Eq (Func BoolS "bar" [Var IntS "v2"]) (Func BoolS "bar" [Var IntS "v3"])))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Eq (Var IntS "v0") (Var IntS "v1"),Binary Eq (Var IntS "v1") (Var IntS "v0")], _maxCount = 2})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Eq (Var IntS "v1") (Var IntS "v0")])], validConstraints = fromList [Binary Implies (Unknown (fromList [("v0",Var IntS "v2"),("v1",Var IntS "v3")]) "$k0") (Binary Eq (Func BoolS "bar" [Var IntS "v2"]) (Func BoolS "bar" [Var IntS "v3"]))], invalidConstraints = fromList [], label = "0.0"},Candidate {solution = fromList [("$k0",fromList [Binary Eq (Var IntS "v0") (Var IntS "v1")])], validConstraints = fromList [Binary Implies (Unknown (fromList [("v0",Var IntS "v2"),("v1",Var IntS "v3")]) "$k0") (Binary Eq (Func BoolS "bar" [Var IntS "v2"]) (Func BoolS "bar" [Var IntS "v3"]))], invalidConstraints = fromList [], label = "0.1"}]


Final candidates:
0.0: [$k0 -> {v1 [37m==[0m v0}] (1 0)
0.1: [$k0 -> {v0 [37m==[0m v1}] (1 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/gfp00.smt2
Qualifier "Pos" [Var IntS "v"] (Binary Le (IntLit 0) (Var IntS "v"))
Qualifier "Neg" [Var IntS "v"] (Binary Le (Var IntS "v") (IntLit 0))
Qualifier "NeqZ" [Var IntS "v"] (Unary Not (Binary Eq (Var IntS "v") (IntLit 0)))
Qualifier "False" [] (Binary Eq (IntLit 66) (IntLit 77))
WFConstraint "$k0" [Var IntS "v0"]
HornConstraint [Var IntS "v1"] (Binary Implies (Unknown (fromList [("v0",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))))
HornConstraint [Var IntS "v2"] (Binary Implies (Binary Eq (Var IntS "v2") (IntLit 10)) (Unknown (fromList [("v0",Var IntS "v2")]) "$k0"))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Le (IntLit 0) (Var IntS "v0"),Binary Le (Var IntS "v0") (IntLit 0),Unary Not (Binary Eq (Var IntS "v0") (IntLit 0)),Binary Eq (IntLit 66) (IntLit 77)], _maxCount = 4})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Le (IntLit 0) (Var IntS "v0")])], validConstraints = fromList [Binary Implies (Unknown (fromList [("v0",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))),Binary Implies (Binary Eq (Var IntS "v2") (IntLit 10)) (Unknown (fromList [("v0",Var IntS "v2")]) "$k0")], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {[36m0[0m [37m<=[0m v0}] (2 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/gfp02.smt2
Qualifier "Pos" [Var IntS "v"] (Binary Le (IntLit 0) (Var IntS "v"))
Qualifier "Neg" [Var IntS "v"] (Binary Le (Var IntS "v") (IntLit 0))
Qualifier "NeqZ" [Var IntS "v"] (Unary Not (Binary Eq (Var IntS "v") (IntLit 0)))
Qualifier "GtTen" [Var IntS "v"] (Binary Lt (Var IntS "v") (IntLit 10))
Qualifier "False" [] (Binary Eq (IntLit 66) (IntLit 77))
WFConstraint "$k0" [Var IntS "v0"]
HornConstraint [Var IntS "v1"] (Binary Implies (Unknown (fromList [("v0",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))))
HornConstraint [Var IntS "v3"] (Binary Implies (Unknown (fromList [("v0",Var IntS "v3")]) "$k0") (Binary Gt (IntLit 11) (Binary Plus (Var IntS "v3") (IntLit 1))))
HornConstraint [Var IntS "v2"] (Binary Implies (Binary Eq (Var IntS "v2") (IntLit 9)) (Unknown (fromList [("v0",Var IntS "v2")]) "$k0"))
HornConstraint [Var IntS "v4"] (Binary Implies (Binary And (Binary Lt (Var IntS "v4") (IntLit 9)) (Binary Gt (Var IntS "v4") (IntLit 3))) (Unknown (fromList [("v0",Var IntS "v4")]) "$k0"))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Le (IntLit 0) (Var IntS "v0"),Binary Le (Var IntS "v0") (IntLit 0),Unary Not (Binary Eq (Var IntS "v0") (IntLit 0)),Binary Lt (Var IntS "v0") (IntLit 10),Binary Eq (IntLit 66) (IntLit 77)], _maxCount = 5})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Lt (Var IntS "v0") (IntLit 10),Binary Le (IntLit 0) (Var IntS "v0")])], validConstraints = fromList [Binary Implies (Unknown (fromList [("v0",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))),Binary Implies (Unknown (fromList [("v0",Var IntS "v3")]) "$k0") (Binary Gt (IntLit 11) (Binary Plus (Var IntS "v3") (IntLit 1))),Binary Implies (Binary Eq (Var IntS "v2") (IntLit 9)) (Unknown (fromList [("v0",Var IntS "v2")]) "$k0"),Binary Implies (Binary And (Binary Lt (Var IntS "v4") (IntLit 9)) (Binary Gt (Var IntS "v4") (IntLit 3))) (Unknown (fromList [("v0",Var IntS "v4")]) "$k0")], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {v0 [37m<[0m [36m10[0m, [36m0[0m [37m<=[0m v0}] (4 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/gfp03.smt2
Qualifier "Pos" [Var IntS "v"] (Binary Le (IntLit 0) (Var IntS "v"))
Qualifier "Neg" [Var IntS "v"] (Binary Le (Var IntS "v") (IntLit 0))
Qualifier "NeqZ" [Var IntS "v"] (Unary Not (Binary Eq (Var IntS "v") (IntLit 0)))
Qualifier "GtTen" [Var IntS "v"] (Binary Lt (Var IntS "v") (IntLit 10))
Qualifier "False" [] (Binary Eq (IntLit 66) (IntLit 77))
WFConstraint "$k0" [Var IntS "b1"]
HornConstraint [Var IntS "v1"] (Binary Implies (Unknown (fromList [("b1",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))))
HornConstraint [Var IntS "v3"] (Binary Implies (Unknown (fromList [("b1",Var IntS "v3")]) "$k0") (Binary Gt (IntLit 11) (Binary Plus (Var IntS "v3") (IntLit 1))))
HornConstraint [Var IntS "v2"] (Binary Implies (Binary Eq (Var IntS "v2") (IntLit 9)) (Unknown (fromList [("b1",Var IntS "v2")]) "$k0"))
HornConstraint [Var IntS "v4"] (Binary Implies (Binary And (Binary Lt (Var IntS "v4") (IntLit 9)) (Binary Gt (Var IntS "v4") (IntLit 3))) (Unknown (fromList [("b1",Var IntS "v4")]) "$k0"))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Le (IntLit 0) (Var IntS "b1"),Binary Le (Var IntS "b1") (IntLit 0),Unary Not (Binary Eq (Var IntS "b1") (IntLit 0)),Binary Lt (Var IntS "b1") (IntLit 10),Binary Eq (IntLit 66) (IntLit 77)], _maxCount = 5})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Lt (Var IntS "b1") (IntLit 10),Binary Le (IntLit 0) (Var IntS "b1")])], validConstraints = fromList [Binary Implies (Unknown (fromList [("b1",Var IntS "v1")]) "$k0") (Binary Lt (IntLit 0) (Binary Plus (Var IntS "v1") (IntLit 1))),Binary Implies (Unknown (fromList [("b1",Var IntS "v3")]) "$k0") (Binary Gt (IntLit 11) (Binary Plus (Var IntS "v3") (IntLit 1))),Binary Implies (Binary Eq (Var IntS "v2") (IntLit 9)) (Unknown (fromList [("b1",Var IntS "v2")]) "$k0"),Binary Implies (Binary And (Binary Lt (Var IntS "v4") (IntLit 9)) (Binary Gt (Var IntS "v4") (IntLit 3))) (Unknown (fromList [("b1",Var IntS "v4")]) "$k0")], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {b1 [37m<[0m [36m10[0m, [36m0[0m [37m<=[0m b1}] (4 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/map_sanity.smt2
Qualifier "Equiv" [Var (VarS "a") "v",Var (VarS "b") "z"] (Binary Eq (Var (VarS "a") "v") (Var (VarS "b") "z"))
Qualifier "False" [Var (VarS "a") "a",Var (VarS "b") "b"] (BoolLit False)
WFConstraint "$k0" [Var IntS "v",Var IntS "x"]
HornConstraint [Var IntS "v",Var IntS "q",Var (MapS IntS IntS) "m1"] (Binary Implies (Binary And (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m1") (IntLit 100))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var IntS "q") (IntLit 0))) (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "q")]) "$k0"))
HornConstraint [Var (MapS BoolS BoolS) "m1"] (Binary Implies (Binary Eq (Var (MapS BoolS BoolS) "m1") (MapLit BoolS (BoolLit True))) (Binary Eq (MapSel (Var (MapS BoolS BoolS) "m1") (BoolLit False)) (BoolLit True)))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Eq (Var IntS "v") (Var IntS "x"),Binary Eq (Var IntS "x") (Var IntS "v"),BoolLit False], _maxCount = 3})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [])], validConstraints = fromList [Binary Implies (Binary Eq (Var (MapS BoolS BoolS) "m1") (MapLit BoolS (BoolLit True))) (Binary Eq (MapSel (Var (MapS BoolS BoolS) "m1") (BoolLit False)) (BoolLit True)),Binary Implies (Binary And (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m1") (IntLit 100))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var IntS "q") (IntLit 0))) (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "q")]) "$k0")], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {}] (2 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/maps.smt2
HornConstraint [Var IntS "v",Var (MapS IntS IntS) "m1"] (Binary Implies (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m1") (IntLit 100))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var IntS "v") (IntLit 0)))
HornConstraint [Var IntS "v",Var (MapS IntS IntS) "m1",Var (MapS IntS IntS) "m2"] (Binary Implies (Binary And (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m2") (IntLit 100))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1)))) (Binary Eq (Var IntS "v") (IntLit 0)))
HornConstraint [Var IntS "v",Var (MapS IntS IntS) "m1",Var (MapS IntS IntS) "m2"] (Binary Implies (Binary And (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m2") (IntLit 10))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1)))) (Binary Eq (Var IntS "v") (IntLit 1)))
HornConstraint [Var IntS "v",Var (MapS IntS IntS) "m1",Var (MapS IntS IntS) "m2",Var (MapS IntS IntS) "m3"] (Binary Implies (Binary And (Binary And (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1)))) (Binary Eq (Var (MapS IntS IntS) "m3") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 20) (IntLit 1)) (IntLit 10) (IntLit 1)))) (Binary Eq (Var (MapS IntS IntS) "m2") (Var (MapS IntS IntS) "m3")))

QMAP
--------
fromList []

Candidates
--------
[Candidate {solution = fromList [], validConstraints = fromList [Binary Implies (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m1") (IntLit 100))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var IntS "v") (IntLit 0)),Binary Implies (Binary And (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m2") (IntLit 10))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1)))) (Binary Eq (Var IntS "v") (IntLit 1)),Binary Implies (Binary And (Binary And (Binary Eq (Var IntS "v") (MapSel (Var (MapS IntS IntS) "m2") (IntLit 100))) (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0)))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1)))) (Binary Eq (Var IntS "v") (IntLit 0)),Binary Implies (Binary And (Binary And (Binary Eq (Var (MapS IntS IntS) "m1") (MapLit IntS (IntLit 0))) (Binary Eq (Var (MapS IntS IntS) "m2") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 10) (IntLit 1)) (IntLit 20) (IntLit 1)))) (Binary Eq (Var (MapS IntS IntS) "m3") (MapUpd (MapUpd (Var (MapS IntS IntS) "m1") (IntLit 20) (IntLit 1)) (IntLit 10) (IntLit 1)))) (Binary Eq (Var (MapS IntS IntS) "m2") (Var (MapS IntS IntS) "m3"))], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [] (4 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/qmap0.smt2
Qualifier "Discard" [Var BoolS "b"] (Binary Eq (Var BoolS "b") (Var BoolS "b"))
Qualifier "Accept" [Var IntS "v"] (Binary Le (Var IntS "v") (IntLit 0))
WFConstraint "$k0" [Var IntS "v0"]
WFConstraint "$k1" [Var BoolS "b0"]
WFConstraint "$k2" [Var IntS "v1",Var BoolS "b1"]

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Le (Var IntS "v0") (IntLit 0)], _maxCount = 1}),("$k1",QSpace {_qualifiers = [Binary Eq (Var BoolS "b0") (Var BoolS "b0")], _maxCount = 1}),("$k2",QSpace {_qualifiers = [Binary Eq (Var BoolS "b1") (Var BoolS "b1"),Binary Le (Var IntS "v1") (IntLit 0)], _maxCount = 2})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList []),("$k1",fromList []),("$k2",fromList [])], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {}, $k1 -> {}, $k2 -> {}] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/qmap1a.smt2
Qualifier "Less" [Var IntS "a",Var IntS "b"] (Binary Lt (Var IntS "a") (Var IntS "b"))
WFConstraint "$k0" [Var IntS "v0",Var IntS "v1"]

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Lt (Var IntS "v0") (Var IntS "v1"),Binary Lt (Var IntS "v1") (Var IntS "v0")], _maxCount = 2})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [])], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {}] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/qmap1b.smt2
Qualifier "Sum" [Var IntS "a",Var IntS "b",Var IntS "c"] (Binary Eq (Binary Plus (Var IntS "a") (Var IntS "b")) (Var IntS "c"))
WFConstraint "$k0" [Var IntS "v0",Var IntS "v1",Var IntS "v2"]

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Eq (Binary Plus (Var IntS "v0") (Var IntS "v1")) (Var IntS "v2"),Binary Eq (Binary Plus (Var IntS "v0") (Var IntS "v2")) (Var IntS "v1"),Binary Eq (Binary Plus (Var IntS "v1") (Var IntS "v0")) (Var IntS "v2"),Binary Eq (Binary Plus (Var IntS "v1") (Var IntS "v2")) (Var IntS "v0"),Binary Eq (Binary Plus (Var IntS "v2") (Var IntS "v0")) (Var IntS "v1"),Binary Eq (Binary Plus (Var IntS "v2") (Var IntS "v1")) (Var IntS "v0")], _maxCount = 6})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [])], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {}] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/qmap2.smt2
Qualifier "Less" [Var IntS "a",Var IntS "b"] (Binary Lt (Var IntS "a") (Var IntS "b"))
Qualifier "Or" [Var BoolS "a",Var BoolS "b"] (Binary Or (Var BoolS "a") (Var BoolS "b"))
WFConstraint "$k0" [Var IntS "v0",Var IntS "v1"]
WFConstraint "$k1" [Var BoolS "v0",Var BoolS "v1"]

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Lt (Var IntS "v0") (Var IntS "v1"),Binary Lt (Var IntS "v1") (Var IntS "v0")], _maxCount = 2}),("$k1",QSpace {_qualifiers = [Binary Or (Var BoolS "v0") (Var BoolS "v1"),Binary Or (Var BoolS "v1") (Var BoolS "v0")], _maxCount = 2})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList []),("$k1",fromList [])], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [$k0 -> {}, $k1 -> {}] (0 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/sets01.smt2
HornConstraint [Var IntS "v",Var (SetS IntS) "m1"] (Binary Implies (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Unary Not (Binary Member (IntLit 100) (Var (SetS IntS) "m1"))))
HornConstraint [Var IntS "v",Var (SetS IntS) "m1",Var (SetS IntS) "m2"] (Binary Implies (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 10])) (SetLit (VarS "_a") [IntLit 20])))) (Unary Not (Binary Member (IntLit 100) (Var (SetS IntS) "m2"))))
HornConstraint [Var IntS "v",Var (SetS IntS) "m1",Var (SetS IntS) "m2"] (Binary Implies (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 10])) (SetLit (VarS "_a") [IntLit 20])))) (Binary Member (IntLit 10) (Var (SetS IntS) "m2")))
HornConstraint [Var IntS "v",Var (SetS IntS) "m1",Var (SetS IntS) "m2",Var (SetS IntS) "m3"] (Binary Implies (Binary And (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 10])) (SetLit (VarS "_a") [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m3") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 20])) (SetLit (VarS "_a") [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m2") (Var (SetS IntS) "m3")))
HornConstraint [Var IntS "v",Var (SetS IntS) "m1",Var (SetS IntS) "m2",Var (SetS IntS) "m3",Var (SetS IntS) "m4",Var (SetS IntS) "m5"] (Binary Implies (Binary And (Binary And (Binary And (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 10])) (SetLit (VarS "_a") [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m3") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 20])) (SetLit (VarS "_a") [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m4") (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m5") (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m2") (Var (SetS IntS) "m3")))

QMAP
--------
fromList []

Candidates
--------
[Candidate {solution = fromList [], validConstraints = fromList [Binary Implies (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Unary Not (Binary Member (IntLit 100) (Var (SetS IntS) "m1"))),Binary Implies (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 10])) (SetLit (VarS "_a") [IntLit 20])))) (Unary Not (Binary Member (IntLit 100) (Var (SetS IntS) "m2"))),Binary Implies (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 10])) (SetLit (VarS "_a") [IntLit 20])))) (Binary Member (IntLit 10) (Var (SetS IntS) "m2")),Binary Implies (Binary And (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 10])) (SetLit (VarS "_a") [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m3") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 20])) (SetLit (VarS "_a") [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m2") (Var (SetS IntS) "m3")),Binary Implies (Binary And (Binary And (Binary And (Binary And (Binary Eq (Var (SetS IntS) "m1") (SetLit IntS [])) (Binary Eq (Var (SetS IntS) "m2") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 10])) (SetLit (VarS "_a") [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m3") (Binary Union (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 20])) (SetLit (VarS "_a") [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m4") (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 10])))) (Binary Eq (Var (SetS IntS) "m5") (Binary Union (Var (SetS IntS) "m1") (SetLit (VarS "_a") [IntLit 20])))) (Binary Eq (Var (SetS IntS) "m2") (Var (SetS IntS) "m3"))], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [] (5 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/test3.smt2
Qualifier "Zog" [Var (VarS "a") "v",Var (VarS "b") "z"] (Binary Eq (Var (VarS "a") "v") (Var (VarS "b") "z"))
WFConstraint "$k0" [Var IntS "v",Var IntS "x"]
HornConstraint [Var IntS "v",Var IntS "q"] (Binary Implies (Binary Eq (Var IntS "v") (Var IntS "q")) (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "q")]) "$k0"))
HornConstraint [Var IntS "v",Var IntS "y"] (Binary Implies (Binary And (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "y")]) "$k0") (Binary Eq (Var IntS "y") (IntLit 10))) (Binary Eq (Var IntS "v") (IntLit 10)))

QMAP
--------
fromList [("$k0",QSpace {_qualifiers = [Binary Eq (Var IntS "v") (Var IntS "x"),Binary Eq (Var IntS "x") (Var IntS "v")], _maxCount = 2})]

Candidates
--------
[Candidate {solution = fromList [("$k0",fromList [Binary Eq (Var IntS "x") (Var IntS "v")])], validConstraints = fromList [Binary Implies (Binary Eq (Var IntS "v") (Var IntS "q")) (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "q")]) "$k0"),Binary Implies (Binary And (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "y")]) "$k0") (Binary Eq (Var IntS "y") (IntLit 10))) (Binary Eq (Var IntS "v") (IntLit 10))], invalidConstraints = fromList [], label = "0.0"},Candidate {solution = fromList [("$k0",fromList [Binary Eq (Var IntS "v") (Var IntS "x")])], validConstraints = fromList [Binary Implies (Binary Eq (Var IntS "v") (Var IntS "q")) (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "q")]) "$k0"),Binary Implies (Binary And (Unknown (fromList [("v",Var IntS "v"),("x",Var IntS "y")]) "$k0") (Binary Eq (Var IntS "y") (IntLit 10))) (Binary Eq (Var IntS "v") (IntLit 10))], invalidConstraints = fromList [], label = "0.1"}]


Final candidates:
0.0: [$k0 -> {x [37m==[0m v}] (2 0)
0.1: [$k0 -> {v [37m==[0m x}] (2 0)
Preparing to find greatest fixpoint...

Inputs
--------
Reading from file test/sample/unary0.smt2
Qualifier "Neg" [Var IntS "i"] (Unary Neg (Var IntS "i"))
Qualifier "Not" [Var BoolS "b"] (Unary Not (Var BoolS "b"))

QMAP
--------
fromList []

Candidates
--------
[Candidate {solution = fromList [], validConstraints = fromList [], invalidConstraints = fromList [], label = "0"}]


Final candidates:
0: [] (0 0)
