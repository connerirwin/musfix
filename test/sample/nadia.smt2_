(declare-fun len   ((Set @0)) Int)
(declare-fun elems ((Set @0)) (Set @0))
;(declare-sort List num)
; num is the number of sorts that this takes

; [] empty set
; ((Set @0) x) singleton set
; + on sets is union
; the weakest solution is `$k0 -> len v0 == 1 + len [], elems v0 == v1 + elems []`
(qualif LenZ  ((x (Set @0)))                   (= (len x) 0))
(qualif Empty ((x (Set @0)))                   (= (elems x) []))
(qualif Plus1 ((x (Set @0))(y (Set @0)))       (= (len x) (+ 1 (len y))))
(qualif SumL  ((x (Set @0))(y (Set @0))(z @0)) (= (elems x) (union (Set z) (elems y)))) ; plus on sets is union

(wf $k0 ((nil (Set @0)) (v0 (Set @0)) (v1 Int)))

(constraint
  (forall ((x Int) (nil (Set @0)) (x4 (Set @0)) (_v (Set @0)))
    (=> (&& (&& (&& (&& (= (elems nil) []) (= (len nil) 0)) ($k0 nil x4 x))
          (= (len _v) (+ 1 (len x4)))) (>= (len x4) 0))
        (= (len _v) 2))))

(constraint
  (forall ((x Int) (nil (Set @0)) (x4 (Set @0)) (_v (Set @0)))
    (=> (&& (&& (&& (&& (= (elems nil) []) (= (len nil) 0)) ($k0 nil x4 x))
          (= (elems _v) (union (Set x) (elems x4)))) (>= (len x4) 0))
        (= (len _v) (Set x)))))
