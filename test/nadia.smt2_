(declare-fun len (((List_t @0))) Int)
(declare-fun elems (((List_t @0))) (Set_t @0))

; [] empty set
; ((List_t @0) x) singleton set
; + on sets is union
; the weakest solution is `$k0 -> len v0 == 1 + len nil, elems v0 == v1 + elems nil`
(qualif LenZ  ((x (List_t @0))) (= (len x) 0))
(qualif Empty ((x (List_t @0))         (= (elems x) ((List_t @0) )))
(qualif Plus1 ((x (List_t @0))(y (List_t @0)))         (= (len x) (+ 1 (len y))))
(qualif SumL  ((x (List_t @0))(y (List_t @0))(z @0)) (= (elems x) (+ ((List_t @0) z) (elems y)))) ; plus on sets is union

(wf $k0 (nil (List_t @0)) (v0 (List_t @0)) (v1 Int))

(constraint
  (forall (nil (List_t @0)) (x4 (List_t @0)) (_v (List_t @0)))
    (=> (&& (&& (&& (&& (= (elems nil) ((List_t @0) )) (&& (= (len nil) 0) (&& ($k0 nil x4 x)
          (&& (= (len _v) (+ 1 (len x4))) (>= (len x4) 0)))))
        (= (len _v) 2))

(constraint
  (forall (nil (List_t @0)) (x4 (List_t @0)) (_v (List_t @0)))
  (=> (&& (= (elems nil) ((List_t @0) )) (&& (= (len nil) 0) (&& ($k0 nil x4 x)
        (&& (= (elems _v) (+ ((List_t @0) x) (elems x4))) (>= (len x4) 0)))))
      (= (elems _v) ((List_t @0) x)))
